name: Soak (Windows self-hosted, 24-72h)

# ==============================================================================
# SOAK TEST WORKFLOW
# ==============================================================================
# 
# Purpose: Long-running stability test (24-72h) to detect memory leaks,
#          resource exhaustion, and intermittent failures
#
# Triggers:
#   - Manual: workflow_dispatch with configurable parameters
#   - Scheduled: Every Monday at 02:00 UTC
#
# Runner Requirements:
#   - Self-hosted Windows runner with 'soak' label
#   - Python 3.11+ in PATH
#   - Min 10 GB free disk space, 8 GB RAM
#
# ==============================================================================

on:
  workflow_dispatch:
    inputs:
      soak_hours:
        description: "Duration in hours (24-72)"
        required: false
        type: number
        default: 3
      iterations:
        description: "Number of iterations (mini-soak mode)"
        required: false
        type: number
        default: 6
      auto_tune:
        description: "Enable auto-tuning between iterations"
        required: false
        type: boolean
        default: true
      overrides_json:
        description: "Runtime overrides JSON (leave empty for defaults)"
        required: false
        type: string
        default: ""
      iteration_timeout_seconds:
        description: "Timeout per iteration (seconds)"
        required: false
        type: number
        default: 1200
      heartbeat_interval_seconds:
        description: "Sleep between iterations (seconds)"
        required: false
        type: number
        default: 300
      validation_timeout_seconds:
        description: "Timeout for validation steps (seconds)"
        required: false
        type: number
        default: 900
      artifact_retention_days:
        description: "Artifact retention (days)"
        required: false
        type: number
        default: 14
      python_path:
        description: "Python executable path (default: auto-detect)"
        required: false
        type: string
        default: "python"
      stay_awake:
        description: "Anti-sleep protection (1=enabled, 0=disabled)"
        required: false
        type: number
        default: 1
  schedule:
    - cron: "0 2 * * 1" # Понедельник в 02:00 UTC

concurrency:
  group: soak-windows
  cancel-in-progress: false

jobs:
  soak:
    runs-on: [self-hosted, windows, soak]
    defaults:
      run:
        shell: pwsh
    timeout-minutes: 4380 # 73 hours (max: 72h + 1h buffer)
    env:
      # ========================================================================
      # RUNTIME CONFIGURATION
      # ========================================================================
      
      # Python: Auto-detect from PATH or use custom path from input
      # Note: Removed hardcoded path for portability across runners
      PYTHON_EXE: ${{ inputs.python_path || 'python' }}
      
      # Pytest: Disable plugin autoload for predictability
      PYTEST_DISABLE_PLUGIN_AUTOLOAD: "1"
      PIP_DISABLE_PIP_VERSION_CHECK: "1"
      PIP_NO_PYTHON_VERSION_WARNING: "1"
      
      # Cache: Disabled on Windows due to tar/gzip issues
      # Set to '1' to enable on Linux/macOS or after installing GNU tar+gzip
      ENABLE_SOAK_CACHE: "0"
      
      # MEGA-PROMPT: Runtime overrides and profile
      MM_PROFILE: "S1"
      MM_ALLOW_MISSING_SECRETS: "1"
      MM_RUNTIME_OVERRIDES_JSON: ${{ inputs.overrides_json }}
      
      # ========================================================================
      # SOAK TEST PARAMETERS (configurable via workflow_dispatch)
      # ========================================================================
      
      # Duration: How long to run the soak test
      SOAK_HOURS: ${{ inputs.soak_hours || '24' }}
      
      # Timeout: Max time per iteration (prevents hanging)
      SOAK_ITERATION_TIMEOUT_SECONDS: ${{ inputs.iteration_timeout_seconds || '1200' }}
      
      # Heartbeat: Sleep between iterations (allows system cooldown)
      SOAK_HEARTBEAT_INTERVAL_SECONDS: ${{ inputs.heartbeat_interval_seconds || '300' }}
      
      # Stay-awake: Prevent Windows sleep during soak (1=enabled, 0=disabled)
      SOAK_STAY_AWAKE: ${{ inputs.stay_awake || '1' }}
      
      # ========================================================================
      # VALIDATION TIMEOUTS (for full_stack_validate.py)
      # ========================================================================
      
      # Step timeout: Max time per validation step
      FSV_TIMEOUT_SEC: ${{ inputs.validation_timeout_seconds || '900' }}
      
      # Retries: Allow flaky tests to retry once
      FSV_RETRIES: "1"
      
      # ========================================================================
      # LOG ROTATION (prevent disk bloat in 72h runs)
      # ========================================================================
      
      # Keep only N newest log files per step
      FSV_MAX_LOGS_PER_STEP: "5"
      
      # Warning threshold for total log size
      FSV_MAX_LOG_SIZE_MB: "500"
      
      # Force cleanup threshold
      FSV_AGGRESSIVE_CLEANUP_MB: "750"
      
      # ========================================================================
      # SECRETS & CREDENTIALS
      # ========================================================================
      
      # API credentials (from repository secrets)
      API_KEY: ${{ secrets.API_KEY }}
      API_SECRET: ${{ secrets.API_SECRET }}
      
      # Telegram notifications (optional - for failure alerts)
      TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
      TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
      
      # Proxy configuration (optional - for restricted networks)
      # Note: Uncomment and set in repository secrets if needed
      # HTTP_PROXY: ${{ secrets.HTTP_PROXY }}
      # HTTPS_PROXY: ${{ secrets.HTTPS_PROXY }}
      
      # ========================================================================
      # VALIDATION & KPI GATE (safe-mode for CI)
      # ========================================================================
      
      # Fixtures directory for tests
      FIXTURES_DIR: "tests/fixtures"
      
      # PYTHONPATH for validation scripts (Windows: semicolon separator)
      PYTHONPATH: "${{ github.workspace }};${{ github.workspace }}\\src"
      
      # ========================================================================
      # ARTIFACT PATHS (centralized configuration)
      # ========================================================================
      
      ARTIFACTS_ROOT: "${{ github.workspace }}/artifacts"
      SOAK_ARTIFACTS_DIR: "${{ github.workspace }}/artifacts/soak"
      CI_ARTIFACTS_DIR: "${{ github.workspace }}/artifacts/ci"

    steps:
      # ======================================================================
      # SETUP: Prepare environment and dependencies
      # ======================================================================
      
      - name: "[1/13] Checkout code"
        id: checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Clear Cargo Cache (to ensure clean build)
        run: |
          Write-Host "Clearing cargo registry and git caches..."
          Remove-Item -Recurse -Force "$($env:USERPROFILE)\.cargo\registry" -ErrorAction SilentlyContinue
          Remove-Item -Recurse -Force "$($env:USERPROFILE)\.cargo\git" -ErrorAction SilentlyContinue
          Write-Host "Cargo cache cleared."

      - name: "[2/13] Install Rust toolchain"
        id: install-rust
        # Purpose: Install Rust for mm-orderbook bindings (PyO3)
        # Uses: 'stable-gnu' to avoid MSVC dependency on Windows
        run: |
          Write-Host "--- Installing Rust toolchain ---"
          Invoke-WebRequest -Uri "https://win.rustup.rs/x86_64" -OutFile "rustup-init.exe"
          # Using the self-contained 'gnu' toolchain to avoid MSVC dependency
          ./rustup-init.exe -y --no-modify-path --default-toolchain stable-gnu
          
          $cargo_bin_path = "$($env:USERPROFILE)\.cargo\bin"
          
          # Update PATH for the CURRENT step to make verification commands work
          Write-Host "Adding cargo to PATH for the current step..."
          $env:PATH = "$cargo_bin_path;" + $env:PATH
          
          # Update PATH for ALL SUBSEQUENT steps
          Write-Host "Adding cargo to PATH for all subsequent steps..."
          echo $cargo_bin_path | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          
          Write-Host "Verifying Rust installation..."
          rustc --version
          cargo --version

      - name: "[3/13] Prefer Windows tar (bsdtar) for actions/cache"
        id: setup-windows-tar
        shell: pwsh
        # Purpose: Ensure actions/cache uses Windows bsdtar instead of Git Bash tar
        # Problem: Git Bash tar requires external gzip which is not available
        # Solution: Put C:\Windows\System32 first in PATH to use built-in bsdtar
        # This prevents "gzip: command not found" warnings in Post job cleanup
        run: |
          Write-Host "--- Configuring PATH to prefer Windows bsdtar ---"
          
          # Prepend Windows System32 to PATH
          $newPath = "C:\Windows\System32;$env:PATH"
          echo "PATH=$newPath" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          
          Write-Host "[OK] Windows System32 prepended to PATH"
          Write-Host "[INFO] actions/cache will now use C:\Windows\System32\tar.exe (bsdtar)"
          Write-Host "[INFO] This avoids 'gzip: command not found' errors in cache post-processing"

      - name: "[4/13] Cache Cargo registry"
        id: cache-cargo
        if: ${{ env.ENABLE_SOAK_CACHE == '1' }}
        # Purpose: Cache Cargo dependencies to speed up Rust builds
        # Key: Based on Cargo.lock for stable hashing
        # Note: Using forward slashes for cross-platform compatibility
        # NOTE: Disabled on Windows (ENABLE_SOAK_CACHE=0) due to tar/gzip issues
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry/index
            ~/.cargo/registry/cache
            ~/.cargo/git/db
          key: ${{ runner.os }}-cargo-${{ hashFiles('rust/**/Cargo.lock', 'rust/**/Cargo.toml') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: "[5/13] Cache Rust build artifacts"
        id: cache-rust-target
        if: ${{ env.ENABLE_SOAK_CACHE == '1' }}
        # Purpose: Cache compiled Rust artifacts for faster rebuilds
        # Note: Using forward slashes for cross-platform compatibility
        # NOTE: Disabled on Windows (ENABLE_SOAK_CACHE=0) due to tar/gzip issues
        uses: actions/cache@v4
        with:
          path: rust/target
          key: ${{ runner.os }}-rust-target-${{ hashFiles('rust/**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-rust-target-

      - name: "[6/13] Setup artifacts directory"
        id: setup-env
        if: always()
        # Purpose: Create artifacts directory structure for test outputs
        # - artifacts/soak/: Test results, metrics, summaries
        # - artifacts/ci/: Validation logs (managed by full_stack_validate.py)
        # Note: Uses 'if: always()' to ensure cleanup can access these dirs
        run: |
          New-Item -ItemType Directory -Force "$env:SOAK_ARTIFACTS_DIR" | Out-Null

      - name: "[7/13] Cache pip dependencies"
        id: cache-pip
        if: ${{ env.ENABLE_SOAK_CACHE == '1' }}
        # Purpose: Cache Python packages to speed up installation
        # Note: Using forward slashes for cross-platform compatibility
        # Windows: ~/AppData/Local/pip/Cache
        # NOTE: Disabled on Windows (ENABLE_SOAK_CACHE=0) due to tar/gzip issues
        uses: actions/cache@v4
        with:
          path: |
            ~/AppData/Local/pip/Cache
            **/__pycache__
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements*.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: "[8/13] Verify Python installation"
        id: verify-python
        # Purpose: Verify Python is accessible and upgrade pip
        # Note: Uses $env:PYTHON_EXE (auto-detected or from input)
        run: |
          Write-Host "Using configured Python:"
          & $env:PYTHON_EXE --version
          & $env:PYTHON_EXE -m pip --version
          & $env:PYTHON_EXE -m pip install --upgrade pip

      - name: "[9/13] Prepare CI requirements"
        id: prepare-reqs
        # Purpose: Filter out private packages (bybit-connector, mm-orderbook)
        # These are not available in public PyPI
        run: |
          Get-Content requirements.txt |
            Where-Object { $_ -notmatch '^(?i)bybit-connector' -and $_ -notmatch '^(?i)git\+' -and $_ -notmatch '^(?i)mm-orderbook' } |
            Set-Content requirements_ci.txt -Encoding ASCII

      - name: "[10/13] Install Python dependencies"
        id: install-deps
        # Purpose: Install all dependencies from filtered requirements
        run: |
          & $env:PYTHON_EXE -m pip install -r requirements_ci.txt

      - name: "[11/13] Install local project package"
        id: install-local
        # Purpose: Install mm-bot package in editable mode (-e .)
        # Note: Uses PYO3_USE_ABI3_FORWARD_COMPATIBILITY for Python 3.13
        # FINAL FIX: Use the env var solution for PyO3 vs Python 3.13 incompatibility
        env:
          PYO3_USE_ABI3_FORWARD_COMPATIBILITY: "1"
        run: |
          Write-Host "--- Installing local mm-bot package ---"
          & $env:PYTHON_EXE -m pip install -e . -v

      - name: "[12/13] Pre-flight checks and transcript"
        id: preflight
        run: |
          Write-Host "================================================"
          Write-Host "PRE-FLIGHT CHECKS"
          Write-Host "================================================"
          
          # Start transcript (optional - don't fail if it doesn't work)
          try {
            Start-Transcript -Path "${{ github.workspace }}\artifacts\soak\soak_windows.log" -Append -ErrorAction Stop | Out-Null
            Write-Host "[TRANSCRIPT] Started logging to soak_windows.log"
          } catch {
            Write-Host "[WARN] Could not start transcript: $($_.Exception.Message)"
            Write-Host "[WARN] Continuing without transcript logging"
          }
          
          # Check Python
          Write-Host "[CHECK] Python..."
          $pythonVersion = & $env:PYTHON_EXE --version 2>&1
          Write-Host "  ✓ $pythonVersion"
          
          # Check Rust (optional, but good to know)
          Write-Host "[CHECK] Rust..."
          try {
            $rustVersion = rustc --version 2>&1
            Write-Host "  ✓ $rustVersion"
          } catch {
            Write-Host "  ⚠ Rust not available (non-critical)"
          }
          
          # Check critical files
          Write-Host "[CHECK] Critical files..."
          $criticalFiles = @(
            "tools\ci\full_stack_validate.py",
            "tools\soak\resource_monitor.py"
          )
          foreach ($file in $criticalFiles) {
            $path = "${{ github.workspace }}\$file"
            if (Test-Path $path) {
              Write-Host "  ✓ $file"
            } else {
              Write-Host "  ✗ $file MISSING"
              exit 1
            }
          }
          
          # Check disk space
          Write-Host "[CHECK] Disk space..."
          $drive = (Get-Item "${{ github.workspace }}").PSDrive
          $freeGB = [math]::Round($drive.Free / 1GB, 2)
          $totalGB = [math]::Round(($drive.Free + $drive.Used) / 1GB, 2)
          Write-Host "  Disk: $freeGB GB free / $totalGB GB total"
          if ($freeGB -lt 5) {
            Write-Host "  ⚠ WARNING: Less than 5GB free space"
          } else {
            Write-Host "  ✓ Sufficient disk space"
          }
          
          # Write summary header
          $summaryFile = "${{ github.workspace }}\artifacts\soak\summary.txt"
          "=============================================" | Out-File $summaryFile -Encoding ascii
          "SOAK TEST SUMMARY" | Add-Content $summaryFile
          "=============================================" | Add-Content $summaryFile
          "Started: $(Get-Date -Format s)Z" | Add-Content $summaryFile
          "Git revision: $(git rev-parse --short HEAD)" | Add-Content $summaryFile
          "Python: $pythonVersion" | Add-Content $summaryFile
          "Duration: $env:SOAK_HOURS hours" | Add-Content $summaryFile
          "Iteration timeout: $env:SOAK_ITERATION_TIMEOUT_SECONDS seconds" | Add-Content $summaryFile
          "Heartbeat interval: $env:SOAK_HEARTBEAT_INTERVAL_SECONDS seconds" | Add-Content $summaryFile
          "Anti-sleep protection: $(if ($env:SOAK_STAY_AWAKE -eq '1') {'ENABLED'} else {'DISABLED'})" | Add-Content $summaryFile
          "=============================================" | Add-Content $summaryFile
          "" | Add-Content $summaryFile
          
          Write-Host "================================================"
          Write-Host "PRE-FLIGHT CHECKS PASSED"
          Write-Host "================================================"

      - name: Start keep-awake background job
        id: init-stay-awake
        if: env.SOAK_STAY_AWAKE == '1'
        shell: pwsh
        run: |
          $script = {
            while ($true) {
              Write-Host "[KEEP-AWAKE] Heartbeat at $(Get-Date -Format o)"
              Start-Sleep -Seconds 300
            }
          }
          $job = Start-Job -ScriptBlock $script
          # Publish job ID to env for cleanup step
          "KEEP_AWAKE_JOB_ID=$($job.Id)" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          Write-Host "[OK] Keep-awake job started. ID=$($job.Id)"

      - name: Seed default overrides if not provided
        id: seed-overrides
        run: |
          Write-Host "==============================================="
          Write-Host "SEEDING RUNTIME OVERRIDES"
          Write-Host "==============================================="
          
          # 1) Прочитать дефолтные оверрайды из репозитория
          $defaultsPath = "tools/soak/default_overrides.json"
          if (-not (Test-Path $defaultsPath)) {
            Write-Error "Defaults file not found: $defaultsPath"
            exit 1
          }
          $defaultsJson = Get-Content $defaultsPath -Raw
          
          # 2) Записать рабочий файл артефактов
          New-Item -Force -ItemType Directory "artifacts/soak" | Out-Null
          $targetPath = "artifacts/soak/runtime_overrides.json"
          $defaultsJson | Set-Content -Encoding utf8 $targetPath
          
          Write-Host "[SEED] Using default_overrides.json"
          Write-Host "| seed | overrides | default_overrides.json |"
          
          # 3A) Экспорт: путь к файлу (простой и надёжный)
          "MM_RUNTIME_OVERRIDES_FILE=$targetPath" | Out-File -Encoding utf8 -Append $env:GITHUB_ENV
          
          # 3B) Экспорт: многострочный JSON через here-doc
          Add-Content -Path $env:GITHUB_ENV -Value "MM_RUNTIME_OVERRIDES_JSON<<EOF"
          Add-Content -Path $env:GITHUB_ENV -Value $defaultsJson
          Add-Content -Path $env:GITHUB_ENV -Value "EOF"

      - name: Run mini-soak with auto-tuning
        id: mini-soak
        if: ${{ inputs.iterations }}
        env:
          SOAK_SLEEP_SECONDS: ${{ inputs.heartbeat_interval_seconds || 300 }}
        run: |
          Write-Host "================================================"
          Write-Host "MINI-SOAK MODE: ${{ inputs.iterations }} iterations"
          Write-Host "================================================"
          
          $iterations = [int]"${{ inputs.iterations }}"
          $autotuneFlag = if ("${{ inputs.auto_tune }}" -eq "true") { "--auto-tune" } else { "" }
          
          Write-Host "Iterations: $iterations"
          Write-Host "Auto-tune: ${{ inputs.auto_tune }}"
          Write-Host "Profile: $env:MM_PROFILE"
          Write-Host "Sleep between iterations: $env:SOAK_SLEEP_SECONDS seconds"
          Write-Host ""
          
          # Preview runtime overrides
          Write-Host "OVERRIDES_FILE=$env:MM_RUNTIME_OVERRIDES_FILE"
          if (Test-Path $env:MM_RUNTIME_OVERRIDES_FILE) {
            $preview = (Get-Content $env:MM_RUNTIME_OVERRIDES_FILE -Raw)
            Write-Host "OVERRIDES_JSON_PREVIEW: $preview"
          }
          Write-Host ""
          
          # Run soak with iterations
          & $env:PYTHON_EXE -m tools.soak.run --iterations $iterations $autotuneFlag --mock
          
          if ($LASTEXITCODE -ne 0) {
            Write-Error "Soak run failed with exit code $LASTEXITCODE"
            exit 1
          }
          
          Write-Host "================================================"
          Write-Host "MINI-SOAK COMPLETED"
          Write-Host "================================================"

      - name: Verify sleep was used
        id: verify-sleep
        if: ${{ inputs.iterations }}
        run: |
          Write-Host "================================================"
          Write-Host "VERIFYING SLEEP BETWEEN ITERATIONS"
          Write-Host "================================================"
          
          # Check if sleep marker was logged
          # Note: In PowerShell, we can't directly grep the previous step's output
          # So we check if iterations > 1 (sleep only happens when iterations > 1)
          $iterations = [int]"${{ inputs.iterations }}"
          if ($iterations -gt 1) {
            Write-Host "✓ Multi-iteration mode: sleep should have been used"
            Write-Host "  Expected sleep between $($iterations - 1) iteration pairs"
          } else {
            Write-Host "ℹ Single iteration: no sleep needed"
          }

      - name: Verify mini-soak artifacts
        id: verify-artifacts
        if: ${{ inputs.iterations }}
        run: |
          Write-Host "================================================"
          Write-Host "VERIFYING MINI-SOAK ARTIFACTS"
          Write-Host "================================================"
          
          $missing = @()
          
          $iter1 = "artifacts\soak\latest\ITER_SUMMARY_1.json"
          if (!(Test-Path $iter1)) {
            $missing += $iter1
            Write-Warning "Missing: $iter1"
          } else {
            Write-Host "✓ Found: $iter1"
          }
          
          $tuning = "artifacts\soak\latest\TUNING_REPORT.json"
          if (!(Test-Path $tuning)) {
            $missing += $tuning
            Write-Warning "Missing: $tuning"
          } else {
            Write-Host "✓ Found: $tuning"
          }
          
          if ($missing.Count -gt 0) {
            Write-Error "Missing $($missing.Count) required artifact(s)"
            exit 1
          }
          
          Write-Host "✅ All required artifacts present"

      - name: Build reports for POST_SOAK_SNAPSHOT
        id: build-reports
        if: ${{ inputs.iterations }}
        continue-on-error: true
        shell: pwsh
        run: |
          Write-Host "================================================"
          Write-Host "GENERATING POST-SOAK REPORTS"
          Write-Host "================================================"
          
          $latestDir = "artifacts\soak\latest"
          if (!(Test-Path $latestDir)) {
            Write-Warning "Latest dir not found, skipping report generation"
            exit 0
          }
          
          $outDir = "$latestDir\reports\analysis"
          New-Item -ItemType Directory -Force -Path $outDir | Out-Null
          
          & $env:PYTHON_EXE -m tools.soak.build_reports `
            --src $latestDir `
            --out $outDir `
            --last-n 8
          
          if ($LASTEXITCODE -ne 0) {
            Write-Warning "Report generation returned exit code $LASTEXITCODE (non-blocking)"
          } else {
            Write-Host "✓ Reports generated"
          }
          Write-Host "================================================"

      - name: Readiness Gate (artifact-based)
        id: check-kpi-gate
        if: ${{ inputs.iterations }}
        shell: pwsh
        env:
          PYTHON_EXE: python
          SOAK_ARTIFACTS_DIR: artifacts/soak/latest
        run: |
          Write-Host "================================================"
          Write-Host "READINESS GATE (artifact-based)"
          Write-Host "================================================"
          & $env:PYTHON_EXE -m tools.soak.ci_gates.readiness_gate `
            --path "$env:SOAK_ARTIFACTS_DIR" `
            --min_maker_taker 0.83 `
            --min_edge 2.9 `
            --max_latency 330 `
            --max_risk 0.40

      - name: Start resource monitoring (background)
        id: start-monitoring
        if: ${{ !inputs.iterations }}
        run: |
          Write-Host "--- Starting resource monitor in background ---"
          $monitorScript = "${{ github.workspace }}\tools\soak\resource_monitor.py"
          $outputFile = "${{ github.workspace }}\artifacts\soak\resources.jsonl"
          
          # Start monitor as background job (samples every 60s)
          $monitorJob = Start-Job -ScriptBlock {
            param($pythonExe, $script, $output, $interval)
            & $pythonExe $script --interval $interval --output $output
          } -ArgumentList $env:PYTHON_EXE, $monitorScript, $outputFile, 60
          
          Write-Host "[MONITOR] Background job started (ID: $($monitorJob.Id))"
          "monitor_job_id=$($monitorJob.Id)" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

      - name: Run long soak loop (legacy mode)
        if: ${{ !inputs.iterations }}
        id: soak-loop
        run: |
          $durationHours = [int]$env:SOAK_HOURS
          if ($durationHours -lt 1 -or $durationHours -gt 72) { $durationHours = 24 }
          $deadline = (Get-Date).AddHours($durationHours)
          Write-Host "Target duration (hours): $durationHours (deadline: $deadline UTC)"
          Write-Host "Soak test will run until: $deadline UTC"
          Write-Host "Current time: $(Get-Date -Format s)Z"
          Write-Host "================================================"
          
          $iterationCount = 0
          $successCount = 0
          $summaryFile = "${{ github.workspace }}\artifacts\soak\summary.txt"
          $ciArtifactsDir = "${{ github.workspace }}\artifacts\ci"
          $metricsFile = "${{ github.workspace }}\artifacts\soak\metrics.jsonl"
          
          # Configuration from env
          $iterationTimeoutSeconds = [int]$env:SOAK_ITERATION_TIMEOUT_SECONDS
          $heartbeatIntervalSeconds = [int]$env:SOAK_HEARTBEAT_INTERVAL_SECONDS
          
          Write-Host "Configuration:"
          Write-Host "  Iteration timeout: $iterationTimeoutSeconds seconds"
          Write-Host "  Heartbeat interval: $heartbeatIntervalSeconds seconds"
          Write-Host ""

          while ((Get-Date) -lt $deadline) {
            $iterationCount++
            $iterStart = Get-Date
            Write-Host ""
            Write-Host "================================================"
            Write-Host "[ITER $iterationCount] Starting iteration at $(Get-Date -Format s)Z"
            Write-Host "================================================"
            
            # Clean up CI artifacts from previous iteration (isolation)
            if (Test-Path $ciArtifactsDir) {
              Write-Host "[CLEANUP] Removing old CI artifacts..."
              try {
                Remove-Item -Path "$ciArtifactsDir\*" -Recurse -Force -ErrorAction SilentlyContinue
                Write-Host "[CLEANUP] CI artifacts cleaned"
              } catch {
                Write-Host "[WARN] Could not clean CI artifacts: $_"
              }
            }
            
            # Run validation with timeout protection
            $validationJob = Start-Job -ScriptBlock {
              param($pythonExe, $workspace)
              Set-Location $workspace
              & $pythonExe tools\ci\full_stack_validate.py 2>&1
              exit $LASTEXITCODE
            } -ArgumentList $env:PYTHON_EXE, "${{ github.workspace }}"
            
            # Wait for job with timeout
            $completed = Wait-Job -Job $validationJob -Timeout $iterationTimeoutSeconds
              $iterSec = ((Get-Date) - $iterStart).TotalSeconds
            
            if ($null -eq $completed) {
              # Timeout occurred
              Write-Host ""
              Write-Host "###############################################"
              Write-Host "# ⏱️ ITERATION TIMEOUT"
              Write-Host "###############################################"
              Write-Host "Iteration $iterationCount exceeded timeout of $iterationTimeoutSeconds seconds"
              Write-Host "Duration: $([math]::Round($iterSec,2))s"
              Write-Host "###############################################"
              Write-Host ""
              
              # Kill the job
              Stop-Job -Job $validationJob -ErrorAction SilentlyContinue
              Remove-Job -Job $validationJob -Force -ErrorAction SilentlyContinue
              
              # Record timeout and exit
              "SOAK FAILED at iteration ${iterationCount}: TIMEOUT after $([math]::Round($iterSec,2))s" | Add-Content $summaryFile -Encoding ascii
              Write-Host "[FATAL] Exiting due to timeout"
              exit 1
            }
            
            # Get output and exit code
            $validationOutput = Receive-Job -Job $validationJob
            $rc = $validationJob.State -eq 'Completed' ? $validationJob.ChildJobs[0].Output[-1] : 1
            
            # Extract exit code from job (PowerShell job doesn't preserve $LASTEXITCODE directly)
            # We check the state and look for error records
            if ($validationJob.State -eq 'Failed' -or $validationJob.Error.Count -gt 0) {
              $rc = 1
            } else {
              # Try to extract exit code from output
              $outputLines = $validationOutput -split "`n"
              foreach ($line in $outputLines) {
                if ($line -match 'RESULT=(FAIL|OK)') {
                  $rc = $Matches[1] -eq 'OK' ? 0 : 1
                  break
                }
              }
            }
            
            Remove-Job -Job $validationJob -Force -ErrorAction SilentlyContinue
            
            # Log iteration summary
            $timestamp = Get-Date -Format s
            $msg = "ITER #$iterationCount rc=$rc duration_s=$([math]::Round($iterSec,2)) at ${timestamp}Z"
            Write-Host ""
            Write-Host "[SUMMARY] $msg"
              $msg | Add-Content $summaryFile -Encoding ascii
            
            # Write structured metrics (JSONL for easy parsing)
            $metricJson = @{
              timestamp = $timestamp
              iteration = $iterationCount
              exit_code = $rc
              duration_seconds = [math]::Round($iterSec, 2)
              status = if ($rc -eq 0) { "success" } else { "failure" }
            } | ConvertTo-Json -Compress
            $metricJson | Add-Content $metricsFile -Encoding ascii
            
            # CRITICAL: Fail fast on error (no retries in soak test)
              if ($rc -ne 0) {
              Write-Host ""
              Write-Host "###############################################"
              Write-Host "# ❌ SOAK TEST FAILED"
              Write-Host "###############################################"
              Write-Host "Iteration: $iterationCount"
              Write-Host "Exit code: $rc"
              Write-Host "Duration: $([math]::Round($iterSec,2))s"
              Write-Host "Time: $(Get-Date -Format s)Z"
              Write-Host "###############################################"
              Write-Host ""
              
              # Show last 30 lines of validation output for immediate debugging
              Write-Host "--- LAST 30 LINES OF OUTPUT ---"
              $validationOutput | Select-Object -Last 30
              Write-Host "--- END OF OUTPUT ---"
              Write-Host ""
              
              # Try to capture recent log files for context
              Write-Host "--- RECENT LOG FILES ---"
              if (Test-Path $ciArtifactsDir) {
                Get-ChildItem "$ciArtifactsDir\*.err.log" | 
                  Sort-Object LastWriteTime -Descending | 
                  Select-Object -First 3 | 
                  ForEach-Object {
                    Write-Host ""
                    Write-Host "=== $($_.Name) ==="
                    Get-Content $_.FullName -Tail 20 -ErrorAction SilentlyContinue
                  }
              }
              Write-Host "--- END OF LOG FILES ---"
              Write-Host ""
              
              # Record failure in summary
              "SOAK FAILED at iteration $iterationCount, rc=$rc" | Add-Content $summaryFile -Encoding ascii
              
              # Exit immediately with error code
              Write-Host "[FATAL] Exiting with error code $rc"
              exit $rc
            }
            
            # Success - continue to next iteration
            $successCount++
            Write-Host "[OK] Iteration $iterationCount completed successfully"
            Write-Host "[STATS] Success rate: $successCount/$iterationCount"
            
            # Heartbeat: wait configured interval before next iteration
            Write-Host "[WAIT] Sleeping for $heartbeatIntervalSeconds seconds before next iteration..."
            Start-Sleep -Seconds $heartbeatIntervalSeconds
            Write-Host "[HB] Heartbeat at $(Get-Date -Format s)Z"
          }
          
          Write-Host ""
          Write-Host "###############################################"
          Write-Host "# ✅ SOAK TEST COMPLETED SUCCESSFULLY"
          Write-Host "###############################################"
          Write-Host "Total iterations: $iterationCount"
          Write-Host "Successful iterations: $successCount"
          Write-Host "Success rate: $([math]::Round(($successCount / $iterationCount) * 100, 2))%"
          Write-Host "Duration: $durationHours hours"
          Write-Host "End time: $(Get-Date -Format s)Z"
          Write-Host "###############################################"
          
          # Write final summary
          "=============================================" | Add-Content $summaryFile -Encoding ascii
          "SOAK COMPLETED: $iterationCount iterations, $successCount successful" | Add-Content $summaryFile -Encoding ascii
          "Finished: $(Get-Date -Format s)Z" | Add-Content $summaryFile -Encoding ascii
          "=============================================" | Add-Content $summaryFile -Encoding ascii

      - name: Stop resource monitoring and analyze
        id: stop-monitoring
        if: always()
        run: |
          Write-Host "--- Stopping resource monitor ---"
          
          # Stop background job if it exists
          if ($env:monitor_job_id) {
            try {
              $job = Get-Job -Id $env:monitor_job_id -ErrorAction SilentlyContinue
              if ($job) {
                Write-Host "[MONITOR] Stopping job ID: $($job.Id)"
                Stop-Job -Id $job.Id -ErrorAction SilentlyContinue
                Remove-Job -Id $job.Id -Force -ErrorAction SilentlyContinue
              }
            } catch {
              Write-Host "[MONITOR] Job already stopped"
            }
          }
          
          # Analyze collected data
          $resourceFile = "${{ github.workspace }}\artifacts\soak\resources.jsonl"
          if (Test-Path $resourceFile) {
            Write-Host "--- Analyzing resource data ---"
            & $env:PYTHON_EXE "${{ github.workspace }}\tools\soak\resource_monitor.py" --analyze $resourceFile
            
            # Add resource summary to main summary
            $analysisFile = "${{ github.workspace }}\artifacts\soak\resources.analysis.json"
            if (Test-Path $analysisFile) {
              "" | Add-Content "${{ github.workspace }}\artifacts\soak\summary.txt"
              "=== RESOURCE ANALYSIS ===" | Add-Content "${{ github.workspace }}\artifacts\soak\summary.txt"
              Get-Content $analysisFile | Add-Content "${{ github.workspace }}\artifacts\soak\summary.txt"
            }
          } else {
            Write-Host "[MONITOR] No resource data collected"
          }

      - name: Stop keep-awake job
        id: cleanup-stay-awake
        if: env.SOAK_STAY_AWAKE == '1'
        shell: pwsh
        run: |
          if ($env:KEEP_AWAKE_JOB_ID) {
            $id = [int]$env:KEEP_AWAKE_JOB_ID
            $j = Get-Job -Id $id -ErrorAction SilentlyContinue
            if ($j) {
              Stop-Job -Id $id -Force -ErrorAction SilentlyContinue
              Remove-Job -Id $id -Force -ErrorAction SilentlyContinue
              Write-Host "[OK] Keep-awake job $id stopped and removed"
            } else {
              Write-Host "[WARN] Keep-awake job $id not found (already finished?)"
            }
          } else {
            # Fallback: stop any running jobs from current session
            Get-Job | Where-Object { $_.State -eq 'Running' } | ForEach-Object {
              Stop-Job -Id $_.Id -Force -ErrorAction SilentlyContinue
              Remove-Job -Id $_.Id -Force -ErrorAction SilentlyContinue
            }
            Write-Host "[INFO] No job id in env, cleaned any running jobs"
          }

      - name: Finalize and snapshot
        id: finalize
        if: always()
        run: |
          Write-Host "================================================"
          Write-Host "FINALIZATION"
          Write-Host "================================================"
          
          # Analyze metrics if available
          $metricsFile = "${{ github.workspace }}\artifacts\soak\metrics.jsonl"
          if (Test-Path $metricsFile) {
            Write-Host "[ANALYSIS] Processing metrics..."
            $metrics = Get-Content $metricsFile | ForEach-Object { $_ | ConvertFrom-Json }
            
            if ($metrics.Count -gt 0) {
              $totalIterations = $metrics.Count
              $successfulIterations = ($metrics | Where-Object { $_.status -eq "success" }).Count
              $failedIterations = ($metrics | Where-Object { $_.status -eq "failure" }).Count
              $avgDuration = ($metrics | Measure-Object -Property duration_seconds -Average).Average
              $maxDuration = ($metrics | Measure-Object -Property duration_seconds -Maximum).Maximum
              $minDuration = ($metrics | Measure-Object -Property duration_seconds -Minimum).Minimum
              
              Write-Host ""
              Write-Host "METRICS SUMMARY:"
              Write-Host "  Total iterations: $totalIterations"
              Write-Host "  Successful: $successfulIterations"
              Write-Host "  Failed: $failedIterations"
              Write-Host "  Success rate: $([math]::Round(($successfulIterations / $totalIterations) * 100, 2))%"
              Write-Host "  Avg duration: $([math]::Round($avgDuration, 2))s"
              Write-Host "  Min duration: $([math]::Round($minDuration, 2))s"
              Write-Host "  Max duration: $([math]::Round($maxDuration, 2))s"
              Write-Host ""
              
              # Write metrics summary to file
              $metricsSummary = @{
                total_iterations = $totalIterations
                successful = $successfulIterations
                failed = $failedIterations
                success_rate_percent = [math]::Round(($successfulIterations / $totalIterations) * 100, 2)
                duration_seconds = @{
                  avg = [math]::Round($avgDuration, 2)
                  min = [math]::Round($minDuration, 2)
                  max = [math]::Round($maxDuration, 2)
                }
              } | ConvertTo-Json -Depth 5
              $metricsSummary | Out-File "${{ github.workspace }}\artifacts\soak\metrics_summary.json" -Encoding ascii
            }
          }
          
          # Finalize log files
          Write-Host "[FINALIZE] Closing transcript..."
          "SOAK finished: $(Get-Date -Format s)Z" | Add-Content "${{ github.workspace }}\artifacts\soak\summary.txt" -ErrorAction SilentlyContinue
          
          # Stop transcript (idempotent - safe if no active transcript)
          try {
            Stop-Transcript -ErrorAction Stop | Out-Null
            Write-Host "[TRANSCRIPT] Stopped logging"
          } catch {
            Write-Host "[INFO] No active transcript to stop (this is normal if Start-Transcript failed earlier)"
          }
          
          # Snapshot environment
          Write-Host "[SNAPSHOT] Capturing environment state..."
          & $env:PYTHON_EXE -m pip freeze | Out-File "${{ github.workspace }}\artifacts\soak\pip-freeze.txt" -Encoding ascii
          git status -sb | Out-File "${{ github.workspace }}\artifacts\soak\git-status.txt" -Encoding ascii
          
          # Create hash manifest for artifact integrity
          Write-Host "[SNAPSHOT] Creating hash manifest..."
          Get-ChildItem "${{ github.workspace }}\artifacts" -Recurse -File -ErrorAction SilentlyContinue |
            Get-FileHash -Algorithm SHA256 -ErrorAction SilentlyContinue |
            ConvertTo-Json -Depth 5 |
            Out-File "${{ github.workspace }}\artifacts\soak\hash_manifest.json" -Encoding ascii
          
          # List artifacts
          Write-Host "[SNAPSHOT] Listing artifacts..."
          Get-ChildItem "${{ github.workspace }}\artifacts\soak" -ErrorAction SilentlyContinue |
            Sort-Object Length -Descending |
            Select-Object Name,Length,LastWriteTime |
            Out-File "${{ github.workspace }}\artifacts\soak\ls.txt" -Encoding ascii

          Write-Host "================================================"
          Write-Host "FINALIZATION COMPLETE"
          Write-Host "================================================"

      - name: Rotate soak artifacts (prevent disk bloat)
        id: rotate-artifacts
        if: always()
        run: |
          Write-Host "================================================"
          Write-Host "ARTIFACT ROTATION"
          Write-Host "================================================"
          
          # Run artifact manager with retention policy
          & $env:PYTHON_EXE -m tools.soak.artifact_manager `
            --path artifacts/soak `
            --ttl-days 7 `
            --max-size-mb 900 `
            --keep-latest 100
          
          $exitCode = $LASTEXITCODE
          
          if ($exitCode -eq 2) {
            Write-Warning "Artifact size exceeds threshold, consider manual cleanup"
          } elseif ($exitCode -ne 0) {
            Write-Error "Artifact rotation failed with exit code $exitCode"
          } else {
            Write-Host "[OK] Artifact rotation completed successfully"
          }
          
          Write-Host "================================================"

      - name: "[12/13] Upload artifacts"
        id: upload-artifacts
        if: always()
        # Purpose: Upload all test artifacts (logs, metrics, summaries)
        # Note: Always runs (if: always()) to capture logs even on failure
        # Note: actions/upload-artifact@v4 handles compression automatically
        #       (no need for manual tar/gzip on Windows)
        # Retention: Configurable via workflow_dispatch input (default: 14 days)
        uses: actions/upload-artifact@v4
        with:
          name: soak-windows-${{ github.run_id }}
          path: |
            artifacts/**
            .pytest_cache/**
          if-no-files-found: ignore
          retention-days: ${{ inputs.artifact_retention_days || 14 }}

      - name: "[13/13] Telegram failure notification"
        id: notify-telegram
        if: failure() && env.TELEGRAM_BOT_TOKEN && env.TELEGRAM_CHAT_ID
        # Purpose: Send alert to Telegram on soak test failure
        # Condition: Only if secrets are configured AND test failed
        run: |
          $msg = "❌ SOAK failed: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }} (commit $(git rev-parse --short HEAD))"
          $uri = "https://api.telegram.org/bot$env:TELEGRAM_BOT_TOKEN/sendMessage"
          Invoke-RestMethod -Uri $uri -Method POST -Body @{
            chat_id = "$env:TELEGRAM_CHAT_ID"
            text    = $msg
          } | Out-Null

